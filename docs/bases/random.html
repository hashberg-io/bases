<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>bases.random API documentation</title>
<meta name="description" content="Functions to generate random data …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bases.random</code></h1>
</header>
<section id="section-intro">
<p>Functions to generate random data.</p>
<p>The main functions are <code><a title="bases.random.rand_bytes" href="#bases.random.rand_bytes">rand_bytes()</a></code> and <code><a title="bases.random.rand_str" href="#bases.random.rand_str">rand_str()</a></code>:</p>
<ul>
<li>the function call <code><a title="bases.random.rand_bytes" href="#bases.random.rand_bytes">rand_bytes()</a>(n)</code> returns an iterator yielding a stream of <code>n</code> random bytestrings</li>
<li>the function call <code>rand_bytes(n, encoding=enc)</code> returns an iterator yielding a stream of <code>n</code> random bytestrings valid for the encoding
(i.e. they should be encoded without error)</li>
<li>the function call <code>rand_str(n, encoding=enc)</code> returns an iterator yielding a stream of <code>n</code> random strings valid for the encoding
(i.e. they should be decoded without error)</li>
<li>the function call <code>rand_str(n, alphabet=alph)</code> returns an iterator yielding a stream of <code>n</code> random strings with characters from the alphabet</li>
<li>the function call <code><a title="bases.random.rand_bytes" href="#bases.random.rand_bytes">rand_bytes()</a></code> returns an iterator yielding an infinite stream of random bytestrings</li>
<li>the function call <code>rand_bytes(encoding=enc)</code> returns an iterator yielding an infinite stream of random bytestrings valid for the encoding</li>
<li>the function call <code>rand_str(encoding=enc)</code> returns an iterator yielding an infinite stream of random strings valid for the encoding</li>
<li>the function call <code>rand_str(alphabet=alph)</code> returns an iterator yielding an infinite stream of random strings with characters from the alphabet</li>
</ul>
<p>Example usage:</p>
<pre><code class="language-python">    &gt;&gt;&gt; from bases import base10, base32
    &gt;&gt;&gt; from bases import random
    &gt;&gt;&gt; my_random_bytes = list(random.rand_bytes(4, encoding=base10))
    &gt;&gt;&gt; [list(b) for b in my_random_bytes]
    [[0, 30, 135, 156, 223, 90, 134, 83, 6, 243, 245],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 216, 87, 1, 2],
     [70, 98, 190, 187, 66, 224, 178],
     [0, 96, 63]]
    &gt;&gt;&gt; my_random_strings = list(random.rand_str(4, encoding=base32))
    &gt;&gt;&gt; my_random_strings
    ['2CQ7ZT6WNI', 'IGQJTGA', 'V6GW3UN64QDAFZA7', 'PUEMOPJ4']
</code></pre>
<p>The <code><a title="bases.random.options" href="#bases.random.options">options()</a></code> context manager is used to set options temporarily, within the scope of a <code>with</code> directive:</p>
<ul>
<li><code>min_bytes</code> and <code>max_bytes</code> bound the length of bytestrings yielded by <code><a title="bases.random.rand_bytes" href="#bases.random.rand_bytes">rand_bytes()</a></code></li>
<li><code>min_chars</code> and <code>max_chars</code> bound the length of strings yielded by <code><a title="bases.random.rand_str" href="#bases.random.rand_str">rand_str()</a></code></li>
</ul>
<p>Options can be set with <code><a title="bases.random.set_options" href="#bases.random.set_options">set_options()</a></code> and reset with <code><a title="bases.random.reset_options" href="#bases.random.reset_options">reset_options()</a></code>. A read-only view on options can be obtained
from <code><a title="bases.random.get_options" href="#bases.random.get_options">get_options()</a></code>, and a read-only view on default options can be obtained from <code><a title="bases.random.default_options" href="#bases.random.default_options">default_options()</a></code>:</p>
<pre><code class="language-py">    &gt;&gt;&gt; random.default_options()
    mappingproxy({'min_bytes': 0, 'max_bytes': 16,
                  'min_chars': 0, 'max_chars': 16})
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Functions to generate random data.

    The main functions are `rand_bytes` and `rand_str`:

    - the function call `rand_bytes(n)` returns an iterator yielding a stream of `n` random bytestrings
    - the function call `rand_bytes(n, encoding=enc)` returns an iterator yielding a stream of `n` random bytestrings valid for the encoding
      (i.e. they should be encoded without error)
    - the function call `rand_str(n, encoding=enc)` returns an iterator yielding a stream of `n` random strings valid for the encoding
      (i.e. they should be decoded without error)
    - the function call `rand_str(n, alphabet=alph)` returns an iterator yielding a stream of `n` random strings with characters from the alphabet
    - the function call `rand_bytes()` returns an iterator yielding an infinite stream of random bytestrings
    - the function call `rand_bytes(encoding=enc)` returns an iterator yielding an infinite stream of random bytestrings valid for the encoding
    - the function call `rand_str(encoding=enc)` returns an iterator yielding an infinite stream of random strings valid for the encoding
    - the function call `rand_str(alphabet=alph)` returns an iterator yielding an infinite stream of random strings with characters from the alphabet

    Example usage:

    ```python
        &gt;&gt;&gt; from bases import base10, base32
        &gt;&gt;&gt; from bases import random
        &gt;&gt;&gt; my_random_bytes = list(random.rand_bytes(4, encoding=base10))
        &gt;&gt;&gt; [list(b) for b in my_random_bytes]
        [[0, 30, 135, 156, 223, 90, 134, 83, 6, 243, 245],
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 216, 87, 1, 2],
         [70, 98, 190, 187, 66, 224, 178],
         [0, 96, 63]]
        &gt;&gt;&gt; my_random_strings = list(random.rand_str(4, encoding=base32))
        &gt;&gt;&gt; my_random_strings
        [&#39;2CQ7ZT6WNI&#39;, &#39;IGQJTGA&#39;, &#39;V6GW3UN64QDAFZA7&#39;, &#39;PUEMOPJ4&#39;]
    ```

    The `options()` context manager is used to set options temporarily, within the scope of a `with` directive:

    - `min_bytes` and `max_bytes` bound the length of bytestrings yielded by `rand_bytes`
    - `min_chars` and `max_chars` bound the length of strings yielded by `rand_str`

    Options can be set with `set_options()` and reset with `reset_options()`. A read-only view on options can be obtained
    from `get_options()`, and a read-only view on default options can be obtained from `default_options()`:

    ```py
        &gt;&gt;&gt; random.default_options()
        mappingproxy({&#39;min_bytes&#39;: 0, &#39;max_bytes&#39;: 16,
                      &#39;min_chars&#39;: 0, &#39;max_chars&#39;: 16})
    ```
&#34;&#34;&#34;

# pylint: disable = global-statement

from contextlib import contextmanager
from itertools import chain, islice
from random import Random # pylint: disable = import-self
from types import MappingProxyType
from typing import Any, Dict, Iterator, Mapping, Optional
from typing_validation import validate

from .alphabet import Alphabet
from .encoding import BaseEncoding, SimpleBaseEncoding, ZeropadBaseEncoding, BlockBaseEncoding, FixcharBaseEncoding


_default_options: Mapping[str, Any] = MappingProxyType({
    &#34;min_bytes&#34;: 0,
    &#34;max_bytes&#34;: 16,
    &#34;min_chars&#34;: 0,
    &#34;max_chars&#34;: 16,
})


_options: Mapping[str, Any] = MappingProxyType(_default_options)
_rand: Random = Random(0)


def reset_options() -&gt; None:
    &#34;&#34;&#34;
        Resets random generation options to their default values.
    &#34;&#34;&#34;
    global _options
    global _rand
    _options = _default_options
    _rand = Random(0)


def default_options() -&gt; Mapping[str, Any]:
    &#34;&#34;&#34;
        Readonly view of the default random generation options.
    &#34;&#34;&#34;
    return _default_options


def get_options() -&gt; Mapping[str, Any]:
    &#34;&#34;&#34;
        Readonly view of the current random generation options.
    &#34;&#34;&#34;
    return _options


@contextmanager
def options(*,
            seed: Optional[int] = None,
            min_bytes: Optional[int] = None,
            max_bytes: Optional[int] = None,
            min_chars: Optional[int] = None,
            max_chars: Optional[int] = None,) -&gt; Iterator[None]:
    &#34;&#34;&#34;
        Returns with-statement context manager for temporary option setting:

        ```py
            with options(**options):
                for value in rand_data(num_samples, encoding):
                    ...
        ```

        See `set_options` for a description of the options.
    &#34;&#34;&#34;
    # pylint: disable = too-many-locals
    for arg in (seed, min_bytes, max_bytes, min_chars, max_chars):
        validate(arg, Optional[int])
    global _options
    global _rand
    try:
        _old_options = _options
        _old_rand = _rand
        set_options(seed=seed,
                    min_bytes=min_bytes, max_bytes=max_bytes,
                    min_chars=min_chars, max_chars=max_chars,)
        yield
    finally:
        _options = _old_options
        _rand = _old_rand


def set_options(*,
                seed: Optional[int] = None,
                min_bytes: Optional[int] = None,
                max_bytes: Optional[int] = None,
                min_chars: Optional[int] = None,
                max_chars: Optional[int] = None,) -&gt; None:
    &#34;&#34;&#34;
        Permanently sets random generation options:

        ```python
            seed: int           # set new random number generator, with this seed
            min_bytes: int      # min length of `bytes` value
            max_bytes: int      # max length of `bytes` value
            min_chars: int      # min length of `str` value
            max_chars: int      # max length of `str` value
        ```

    &#34;&#34;&#34;
    # pylint: disable = too-many-branches, too-many-locals, too-many-statements
    for arg in (seed, min_bytes, max_bytes, min_chars, max_chars):
        validate(arg, Optional[int])
    global _options
    global _rand
    # set newly passed options
    _new_options: Dict[str, Any] = {}
    if seed is not None:
        _rand = Random(seed)
    if min_bytes is not None:
        if min_bytes &lt; 0:
            raise ValueError(&#34;Value for min_bytes is negative.&#34;)
        _new_options[&#34;min_bytes&#34;] = min_bytes
    if max_bytes is not None:
        if max_bytes &lt; 0:
            raise ValueError(&#34;Value for max_bytes is negative.&#34;)
        _new_options[&#34;max_bytes&#34;] = max_bytes
    if min_chars is not None:
        if min_chars &lt; 0:
            raise ValueError(&#34;Value for min_chars is negative.&#34;)
        _new_options[&#34;min_chars&#34;] = min_chars
    if max_chars is not None:
        if max_chars &lt; 0:
            raise ValueError(&#34;Value for max_chars is negative.&#34;)
        _new_options[&#34;max_chars&#34;] = max_chars
    # pass-through other options with former values
    for k, v in _options.items():
        if k not in _new_options:
            _new_options[k] = v
    # check compatibility conditions
    if _new_options[&#34;min_bytes&#34;] &gt; _new_options[&#34;max_bytes&#34;]:
        raise ValueError(&#34;Value for min_bytes is larger than value for max_bytes.&#34;)
    if _new_options[&#34;min_chars&#34;] &gt; _new_options[&#34;max_chars&#34;]:
        raise ValueError(&#34;Value for min_chars is larger than value for max_chars.&#34;)
    # update options
    _options = MappingProxyType(_new_options)


def rand_bytes(n: Optional[int] = None, *, encoding: Optional[BaseEncoding] = None) -&gt; Iterator[bytes]:
    &#34;&#34;&#34;
        Generates a stream of random `bytes` objects.
        If a number `n` is given, that number of samples is yelded.
        If an encoding `encoding` is given, only bytes valid for that encoding are yielded.

        Example usage:

        ```py
        &gt;&gt;&gt; my_random_bytes = list(random.rand_bytes(4, encoding=base10))
        &gt;&gt;&gt; [list(b) for b in my_random_bytes]
        [[0, 30, 135, 156, 223, 90, 134, 83, 6, 243, 245],
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 216, 87, 1, 2],
         [70, 98, 190, 187, 66, 224, 178],
         [0, 96, 63]]
        ```
    &#34;&#34;&#34;
    validate(n, Optional[int])
    validate(encoding, Optional[BaseEncoding])
    if encoding is None:
        return rand_raw_bytes(n)
    if isinstance(encoding, SimpleBaseEncoding):
        return _rand_bytes_simple_enc(n, encoding)
    if isinstance(encoding, ZeropadBaseEncoding):
        return _rand_bytes_zeropad_enc(n, encoding)
    if isinstance(encoding, BlockBaseEncoding):
        return _rand_bytes_block_enc(n, encoding)
    if isinstance(encoding, FixcharBaseEncoding):
        return _rand_bytes_fixedchar_enc(n, encoding)
    raise ValueError(f&#34;Unsupported encoding type {type(encoding)}&#34;)


def rand_raw_bytes(n: Optional[int] = None, *, min_bytes: Optional[int] = None, max_bytes: Optional[int] = None) -&gt; Iterator[bytes]:
    &#34;&#34;&#34;
        Generates a stream of random `bytes` objects.
        If a number `n` is given, that number of samples is yelded.
        The optional `min_bytes` and `max_bytes` parameters can be used to set a minimum/maximum length
        for the `bytes` objects: if `None`, the values are fetched from `get_options`.
    &#34;&#34;&#34;
    validate(n, Optional[int])
    validate(min_bytes, Optional[int])
    validate(max_bytes, Optional[int])
    if n is not None and n &lt; 0:
        raise ValueError()
    if min_bytes is None:
        min_bytes = _options[&#34;min_bytes&#34;]
    if max_bytes is None:
        max_bytes = _options[&#34;max_bytes&#34;]
    rand = _rand
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random length
        l = rand.randint(min_bytes, max_bytes)
        # yield random unsigned integer filling l bytes
        i = rand.randrange(0, 256**l)
        yield i.to_bytes(l, byteorder=&#34;big&#34;)
        yielded += 1


def _rand_bytes_simple_enc(n: Optional[int], _: SimpleBaseEncoding) -&gt; Iterator[bytes]:
    if n is not None and n &lt; 0:
        raise ValueError()
    min_bytes = _options[&#34;min_bytes&#34;]
    max_bytes = _options[&#34;max_bytes&#34;]
    rand = _rand
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random length
        l = rand.randint(min_bytes, max_bytes)
        # yield random unsigned integer filling l bytes with no leading zero bytes
        if l == 0:
            i = 0
        else:
            i = rand.randrange(256**(l-1), 256**l)
        yield i.to_bytes(l, byteorder=&#34;big&#34;)
        yielded += 1

def _rand_bytes_zeropad_enc(n: Optional[int], _: ZeropadBaseEncoding) -&gt; Iterator[bytes]:
    if n is not None and n &lt; 0:
        raise ValueError()
    min_bytes = _options[&#34;min_bytes&#34;]
    max_bytes = _options[&#34;max_bytes&#34;]
    rand = _rand
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random length
        l = rand.randint(min_bytes, max_bytes)
        # sample random number of leading zero bytes
        z = rand.randint(0, l)
        # yield random unsigned integer filling l-z bytes
        if l == z:
            i = 0
        else:
            i = rand.randrange(256**(l-z-1), 256**(l-z))
        yield i.to_bytes(l, byteorder=&#34;big&#34;)
        yielded += 1

def _rand_bytes_block_enc(n: Optional[int], encoding: BlockBaseEncoding) -&gt; Iterator[bytes]:
    if n is not None and n &lt; 0:
        raise ValueError()
    min_bytes = _options[&#34;min_bytes&#34;]
    max_bytes = _options[&#34;max_bytes&#34;]
    rand = _rand
    # pre-compute valid bytestring lengths for block base encoding
    block_nbytes = encoding.block_nbytes
    nbytes2nchars = encoding.nbytes2nchars
    valid_lengths = [l for l in range(min_bytes, max_bytes+1)
                     if l%block_nbytes == 0 or l%block_nbytes in nbytes2nchars]
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random valid length
        l = rand.choice(valid_lengths)
        # yield random unsigned integer filling l bytes
        i = rand.randrange(0, 256**l)
        yield i.to_bytes(l, byteorder=&#34;big&#34;)
        yielded += 1


def _rand_bytes_fixedchar_enc(n: Optional[int], _: FixcharBaseEncoding) -&gt; Iterator[bytes]:
    return rand_raw_bytes(n)


def rand_str(n: Optional[int] = None, *, encoding: Optional[BaseEncoding]=None, alphabet: Optional[Alphabet]=None) -&gt; Iterator[str]:
    &#34;&#34;&#34;
        Generates a stream of random strings.
        If a number `n` is given, that number of samples is yelded.
        Exactly one of `encoding` or `alphabet` must be given:
        - if an `encoding` is given, only strings valid for that encoding are yielded
        - if an `alphabet` is given, only strings valid for that alphabet are yielded

        Example usage:

        ```py
        &gt;&gt;&gt; my_random_strings = list(random.rand_str(4, encoding=base32))
        &gt;&gt;&gt; my_random_strings
        [&#39;2CQ7ZT6WNI&#39;, &#39;IGQJTGA&#39;, &#39;V6GW3UN64QDAFZA7&#39;, &#39;PUEMOPJ4&#39;]
        ```

    &#34;&#34;&#34;
    validate(n, Optional[int])
    validate(encoding, Optional[BaseEncoding])
    validate(alphabet, Optional[Alphabet])
    if encoding is None:
        if alphabet is None:
            raise ValueError(&#34;One of &#39;encoding&#39; or &#39;alphabet&#39; must be specified.&#34;)
        return _rand_alphabet_string(n, alphabet)
    if alphabet is not None:
        raise ValueError(&#34;Exactly one of &#39;encoding&#39; or &#39;alphabet&#39; must be specified.&#34;)
    if isinstance(encoding, SimpleBaseEncoding):
        return _rand_str_simple_enc(n, encoding)
    if isinstance(encoding, ZeropadBaseEncoding):
        return _rand_str_zeropad_enc(n, encoding)
    if isinstance(encoding, BlockBaseEncoding):
        return _rand_str_block_enc(n, encoding)
    if isinstance(encoding, FixcharBaseEncoding):
        return _rand_str_fixedchar_enc(n, encoding)
    raise ValueError(f&#34;Unsupported encoding type {type(encoding)}&#34;)

def rand_char(n: Optional[int] = None, *, alphabet: Alphabet, non_zero: bool = False) -&gt; Iterator[str]:
    &#34;&#34;&#34;
        Generates a stream of random characters from the alphabet (one character yielded at a time).
        If a number `n` is given, that number of samples is yelded.
        If `non_zero` is `True`, the zero character for the alphabet is not yielded.
    &#34;&#34;&#34;
    if n is not None and n &lt; 0:
        raise ValueError()
    start = 1 if non_zero else 0
    end = len(alphabet)
    rand = _rand
    yielded = 0
    while n is None or yielded &lt; n:
        # yield random character (excluding zero character, if non_zero is True)
        idx = rand.randrange(start, end)
        yield alphabet[idx]
        yielded += 1

def _rand_alphabet_string(n: Optional[int], alphabet: Alphabet) -&gt; Iterator[str]:
    if n is not None and n &lt; 0:
        raise ValueError()
    min_chars = _options[&#34;min_chars&#34;]
    max_chars = _options[&#34;max_chars&#34;]
    rand = _rand
    # infinte random character stream
    rand_char_stream = rand_char(alphabet=alphabet)
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random length
        l = rand.randint(min_chars, max_chars)
        # yield random string filling l characters
        yield &#34;&#34;.join(islice(rand_char_stream, l))
        yielded += 1


def _rand_str_simple_enc(n: Optional[int], encoding: SimpleBaseEncoding) -&gt; Iterator[str]:
    if n is not None and n &lt; 0:
        raise ValueError()
    min_chars = _options[&#34;min_chars&#34;]
    max_chars = _options[&#34;max_chars&#34;]
    rand = _rand
    # infinte random character streams
    rand_char_stream = rand_char(alphabet=encoding.alphabet)
    rand_nonzero_char_stream = rand_char(alphabet=encoding.alphabet, non_zero=True)
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random length
        l = rand.randint(min_chars, max_chars)
        # yield random str filling l characters with no leading zero characters
        if l == 0:
            yield &#34;&#34;
        else:
            yield &#34;&#34;.join(chain(islice(rand_nonzero_char_stream, 1),
                                islice(rand_char_stream, l-1)))
        yielded += 1


def _rand_str_zeropad_enc(n: Optional[int], encoding: ZeropadBaseEncoding) -&gt; Iterator[str]:
    if n is not None and n &lt; 0:
        raise ValueError()
    min_chars = _options[&#34;min_chars&#34;]
    max_chars = _options[&#34;max_chars&#34;]
    rand = _rand
    # zero character
    zero_char = encoding.zero_char
    # infinte random character streams
    rand_char_stream = rand_char(alphabet=encoding.alphabet)
    rand_nonzero_char_stream = rand_char(alphabet=encoding.alphabet, non_zero=True)
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random length
        l = rand.randint(min_chars, max_chars)
        # sample random number of leading zero chars
        z = rand.randint(0, l)
        # yield random str filling l characters with given number of leading zeros
        if l-z == 0:
            yield zero_char*z
        else:
            yield zero_char*z+&#34;&#34;.join(chain(islice(rand_nonzero_char_stream, 1),
                                            islice(rand_char_stream, l-z-1)))
        yielded += 1

def rand_block_chars(n: Optional[int] = None, *, block_nchars: int, encoding: BlockBaseEncoding) -&gt; Iterator[str]:
    &#34;&#34;&#34;
        Generates a stream of random char blocks for a block base encoding.
        If a number `n` is given, that number of samples is yelded.
        The number `block_nchars` of characters in the blocks must be valid for the encoding.
    &#34;&#34;&#34;
    if n is not None and n &lt; 0:
        raise ValueError()
    # extract block size in chars and bytes
    nchars2nbytes = encoding.nchars2nbytes
    if block_nchars not in nchars2nbytes:
        raise ValueError(f&#34;Invalid number of characters per block ({block_nchars})&#34;)
    block_nbytes = nchars2nbytes[block_nchars]
    # infinite random byte stream
    rand_bytes_stream = rand_raw_bytes(min_bytes=1, max_bytes=1)
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        block_bytes = b&#34;&#34;.join(islice(rand_bytes_stream, block_nbytes))
        s = encoding.encode(block_bytes)
        yield s
        yielded += 1

def _rand_str_block_enc(n: Optional[int], encoding: BlockBaseEncoding) -&gt; Iterator[str]:
    if n is not None and n &lt; 0:
        raise ValueError()
    min_chars = _options[&#34;min_chars&#34;]
    max_chars = _options[&#34;max_chars&#34;]
    rand = _rand
    # pre-compute valid string lengths for block base encoding
    block_nchars = encoding.block_nchars
    nchars2nbytes = encoding.nchars2nbytes
    valid_lengths = [l for l in range(min_chars, max_chars+1)
                     if l%block_nchars == 0 or l%block_nchars in nchars2nbytes]
    # infinte random character streams
    rand_block_stream = {
        nchars: rand_block_chars(block_nchars=nchars, encoding=encoding)
        for nchars in nchars2nbytes
    }
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random valid length
        l = rand.choice(valid_lengths)
        num_full_blocks, final_block_nchars = divmod(l, block_nchars)
        full_blocks = islice(rand_block_stream[block_nchars], num_full_blocks)
        if final_block_nchars == 0:
            yield &#34;&#34;.join(full_blocks)
        else:
            final_block = islice(rand_block_stream[final_block_nchars], 1)
            yield &#34;&#34;.join(chain(full_blocks, final_block))
        yielded += 1

def _rand_str_fixedchar_enc(n: Optional[int], encoding: FixcharBaseEncoding) -&gt; Iterator[str]:
    # pylint: disable = too-many-locals
    if n is not None and n &lt; 0:
        raise ValueError()
    min_chars = _options[&#34;min_chars&#34;]
    max_chars = _options[&#34;max_chars&#34;]
    rand = _rand
    # pre-compute valid string lengths for fixed-char base encoding
    alphabet = encoding.alphabet
    char_nbits = encoding.char_nbits
    valid_lengths = [l for l in range(min_chars, max_chars+1)
                     if (l*char_nbits)%8 &lt; char_nbits]
    # infinte random character stream
    rand_char_stream = rand_char(alphabet=encoding.alphabet)
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random length
        l = rand.choice(valid_lengths)
        # yield random str filling l characters with pad bits set to zero
        extra_nbits = (l*char_nbits)%8
        if extra_nbits == 0:
            s = &#34;&#34;.join(islice(rand_char_stream, l))
        else:
            all_chars_but_last = &#34;&#34;.join(islice(rand_char_stream, l-1))
            last_char_idx = rand.randrange(0, 2**(char_nbits-extra_nbits))&lt;&lt;extra_nbits
            last_char = alphabet[last_char_idx]
            s = all_chars_but_last+last_char
        if encoding.padding == &#34;ignore&#34;:
            yield s
        else:
            yield encoding.pad_string(s)
        yielded += 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bases.random.default_options"><code class="name flex">
<span>def <span class="ident">default_options</span></span>(<span>) ‑> Mapping[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Readonly view of the default random generation options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def default_options() -&gt; Mapping[str, Any]:
    &#34;&#34;&#34;
        Readonly view of the default random generation options.
    &#34;&#34;&#34;
    return _default_options</code></pre>
</details>
</dd>
<dt id="bases.random.get_options"><code class="name flex">
<span>def <span class="ident">get_options</span></span>(<span>) ‑> Mapping[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Readonly view of the current random generation options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_options() -&gt; Mapping[str, Any]:
    &#34;&#34;&#34;
        Readonly view of the current random generation options.
    &#34;&#34;&#34;
    return _options</code></pre>
</details>
</dd>
<dt id="bases.random.options"><code class="name flex">
<span>def <span class="ident">options</span></span>(<span>*, seed: Optional[int] = None, min_bytes: Optional[int] = None, max_bytes: Optional[int] = None, min_chars: Optional[int] = None, max_chars: Optional[int] = None) ‑> Iterator[None]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns with-statement context manager for temporary option setting:</p>
<pre><code class="language-py">    with options(**options):
        for value in rand_data(num_samples, encoding):
            ...
</code></pre>
<p>See <code><a title="bases.random.set_options" href="#bases.random.set_options">set_options()</a></code> for a description of the options.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def options(*,
            seed: Optional[int] = None,
            min_bytes: Optional[int] = None,
            max_bytes: Optional[int] = None,
            min_chars: Optional[int] = None,
            max_chars: Optional[int] = None,) -&gt; Iterator[None]:
    &#34;&#34;&#34;
        Returns with-statement context manager for temporary option setting:

        ```py
            with options(**options):
                for value in rand_data(num_samples, encoding):
                    ...
        ```

        See `set_options` for a description of the options.
    &#34;&#34;&#34;
    # pylint: disable = too-many-locals
    for arg in (seed, min_bytes, max_bytes, min_chars, max_chars):
        validate(arg, Optional[int])
    global _options
    global _rand
    try:
        _old_options = _options
        _old_rand = _rand
        set_options(seed=seed,
                    min_bytes=min_bytes, max_bytes=max_bytes,
                    min_chars=min_chars, max_chars=max_chars,)
        yield
    finally:
        _options = _old_options
        _rand = _old_rand</code></pre>
</details>
</dd>
<dt id="bases.random.rand_block_chars"><code class="name flex">
<span>def <span class="ident">rand_block_chars</span></span>(<span>n: Optional[int] = None, *, block_nchars: int, encoding: <a title="bases.encoding.block.BlockBaseEncoding" href="encoding/block.html#bases.encoding.block.BlockBaseEncoding">BlockBaseEncoding</a>) ‑> Iterator[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a stream of random char blocks for a block base encoding.
If a number <code>n</code> is given, that number of samples is yelded.
The number <code>block_nchars</code> of characters in the blocks must be valid for the encoding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand_block_chars(n: Optional[int] = None, *, block_nchars: int, encoding: BlockBaseEncoding) -&gt; Iterator[str]:
    &#34;&#34;&#34;
        Generates a stream of random char blocks for a block base encoding.
        If a number `n` is given, that number of samples is yelded.
        The number `block_nchars` of characters in the blocks must be valid for the encoding.
    &#34;&#34;&#34;
    if n is not None and n &lt; 0:
        raise ValueError()
    # extract block size in chars and bytes
    nchars2nbytes = encoding.nchars2nbytes
    if block_nchars not in nchars2nbytes:
        raise ValueError(f&#34;Invalid number of characters per block ({block_nchars})&#34;)
    block_nbytes = nchars2nbytes[block_nchars]
    # infinite random byte stream
    rand_bytes_stream = rand_raw_bytes(min_bytes=1, max_bytes=1)
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        block_bytes = b&#34;&#34;.join(islice(rand_bytes_stream, block_nbytes))
        s = encoding.encode(block_bytes)
        yield s
        yielded += 1</code></pre>
</details>
</dd>
<dt id="bases.random.rand_bytes"><code class="name flex">
<span>def <span class="ident">rand_bytes</span></span>(<span>n: Optional[int] = None, *, encoding: Optional[<a title="bases.encoding.base.BaseEncoding" href="encoding/base.html#bases.encoding.base.BaseEncoding">BaseEncoding</a>] = None) ‑> Iterator[bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a stream of random <code>bytes</code> objects.
If a number <code>n</code> is given, that number of samples is yelded.
If an encoding <code>encoding</code> is given, only bytes valid for that encoding are yielded.</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; my_random_bytes = list(random.rand_bytes(4, encoding=base10))
&gt;&gt;&gt; [list(b) for b in my_random_bytes]
[[0, 30, 135, 156, 223, 90, 134, 83, 6, 243, 245],
 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 216, 87, 1, 2],
 [70, 98, 190, 187, 66, 224, 178],
 [0, 96, 63]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand_bytes(n: Optional[int] = None, *, encoding: Optional[BaseEncoding] = None) -&gt; Iterator[bytes]:
    &#34;&#34;&#34;
        Generates a stream of random `bytes` objects.
        If a number `n` is given, that number of samples is yelded.
        If an encoding `encoding` is given, only bytes valid for that encoding are yielded.

        Example usage:

        ```py
        &gt;&gt;&gt; my_random_bytes = list(random.rand_bytes(4, encoding=base10))
        &gt;&gt;&gt; [list(b) for b in my_random_bytes]
        [[0, 30, 135, 156, 223, 90, 134, 83, 6, 243, 245],
         [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 49, 216, 87, 1, 2],
         [70, 98, 190, 187, 66, 224, 178],
         [0, 96, 63]]
        ```
    &#34;&#34;&#34;
    validate(n, Optional[int])
    validate(encoding, Optional[BaseEncoding])
    if encoding is None:
        return rand_raw_bytes(n)
    if isinstance(encoding, SimpleBaseEncoding):
        return _rand_bytes_simple_enc(n, encoding)
    if isinstance(encoding, ZeropadBaseEncoding):
        return _rand_bytes_zeropad_enc(n, encoding)
    if isinstance(encoding, BlockBaseEncoding):
        return _rand_bytes_block_enc(n, encoding)
    if isinstance(encoding, FixcharBaseEncoding):
        return _rand_bytes_fixedchar_enc(n, encoding)
    raise ValueError(f&#34;Unsupported encoding type {type(encoding)}&#34;)</code></pre>
</details>
</dd>
<dt id="bases.random.rand_char"><code class="name flex">
<span>def <span class="ident">rand_char</span></span>(<span>n: Optional[int] = None, *, alphabet: <a title="bases.alphabet.abstract.Alphabet" href="alphabet/abstract.html#bases.alphabet.abstract.Alphabet">Alphabet</a>, non_zero: bool = False) ‑> Iterator[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a stream of random characters from the alphabet (one character yielded at a time).
If a number <code>n</code> is given, that number of samples is yelded.
If <code>non_zero</code> is <code>True</code>, the zero character for the alphabet is not yielded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand_char(n: Optional[int] = None, *, alphabet: Alphabet, non_zero: bool = False) -&gt; Iterator[str]:
    &#34;&#34;&#34;
        Generates a stream of random characters from the alphabet (one character yielded at a time).
        If a number `n` is given, that number of samples is yelded.
        If `non_zero` is `True`, the zero character for the alphabet is not yielded.
    &#34;&#34;&#34;
    if n is not None and n &lt; 0:
        raise ValueError()
    start = 1 if non_zero else 0
    end = len(alphabet)
    rand = _rand
    yielded = 0
    while n is None or yielded &lt; n:
        # yield random character (excluding zero character, if non_zero is True)
        idx = rand.randrange(start, end)
        yield alphabet[idx]
        yielded += 1</code></pre>
</details>
</dd>
<dt id="bases.random.rand_raw_bytes"><code class="name flex">
<span>def <span class="ident">rand_raw_bytes</span></span>(<span>n: Optional[int] = None, *, min_bytes: Optional[int] = None, max_bytes: Optional[int] = None) ‑> Iterator[bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a stream of random <code>bytes</code> objects.
If a number <code>n</code> is given, that number of samples is yelded.
The optional <code>min_bytes</code> and <code>max_bytes</code> parameters can be used to set a minimum/maximum length
for the <code>bytes</code> objects: if <code>None</code>, the values are fetched from <code><a title="bases.random.get_options" href="#bases.random.get_options">get_options()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand_raw_bytes(n: Optional[int] = None, *, min_bytes: Optional[int] = None, max_bytes: Optional[int] = None) -&gt; Iterator[bytes]:
    &#34;&#34;&#34;
        Generates a stream of random `bytes` objects.
        If a number `n` is given, that number of samples is yelded.
        The optional `min_bytes` and `max_bytes` parameters can be used to set a minimum/maximum length
        for the `bytes` objects: if `None`, the values are fetched from `get_options`.
    &#34;&#34;&#34;
    validate(n, Optional[int])
    validate(min_bytes, Optional[int])
    validate(max_bytes, Optional[int])
    if n is not None and n &lt; 0:
        raise ValueError()
    if min_bytes is None:
        min_bytes = _options[&#34;min_bytes&#34;]
    if max_bytes is None:
        max_bytes = _options[&#34;max_bytes&#34;]
    rand = _rand
    # main yielding loop
    yielded = 0
    while n is None or yielded &lt; n:
        # sample random length
        l = rand.randint(min_bytes, max_bytes)
        # yield random unsigned integer filling l bytes
        i = rand.randrange(0, 256**l)
        yield i.to_bytes(l, byteorder=&#34;big&#34;)
        yielded += 1</code></pre>
</details>
</dd>
<dt id="bases.random.rand_str"><code class="name flex">
<span>def <span class="ident">rand_str</span></span>(<span>n: Optional[int] = None, *, encoding: Optional[<a title="bases.encoding.base.BaseEncoding" href="encoding/base.html#bases.encoding.base.BaseEncoding">BaseEncoding</a>] = None, alphabet: Optional[<a title="bases.alphabet.abstract.Alphabet" href="alphabet/abstract.html#bases.alphabet.abstract.Alphabet">Alphabet</a>] = None) ‑> Iterator[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a stream of random strings.
If a number <code>n</code> is given, that number of samples is yelded.
Exactly one of <code>encoding</code> or <code>alphabet</code> must be given:
- if an <code>encoding</code> is given, only strings valid for that encoding are yielded
- if an <code>alphabet</code> is given, only strings valid for that alphabet are yielded</p>
<p>Example usage:</p>
<pre><code class="language-py">&gt;&gt;&gt; my_random_strings = list(random.rand_str(4, encoding=base32))
&gt;&gt;&gt; my_random_strings
['2CQ7ZT6WNI', 'IGQJTGA', 'V6GW3UN64QDAFZA7', 'PUEMOPJ4']
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand_str(n: Optional[int] = None, *, encoding: Optional[BaseEncoding]=None, alphabet: Optional[Alphabet]=None) -&gt; Iterator[str]:
    &#34;&#34;&#34;
        Generates a stream of random strings.
        If a number `n` is given, that number of samples is yelded.
        Exactly one of `encoding` or `alphabet` must be given:
        - if an `encoding` is given, only strings valid for that encoding are yielded
        - if an `alphabet` is given, only strings valid for that alphabet are yielded

        Example usage:

        ```py
        &gt;&gt;&gt; my_random_strings = list(random.rand_str(4, encoding=base32))
        &gt;&gt;&gt; my_random_strings
        [&#39;2CQ7ZT6WNI&#39;, &#39;IGQJTGA&#39;, &#39;V6GW3UN64QDAFZA7&#39;, &#39;PUEMOPJ4&#39;]
        ```

    &#34;&#34;&#34;
    validate(n, Optional[int])
    validate(encoding, Optional[BaseEncoding])
    validate(alphabet, Optional[Alphabet])
    if encoding is None:
        if alphabet is None:
            raise ValueError(&#34;One of &#39;encoding&#39; or &#39;alphabet&#39; must be specified.&#34;)
        return _rand_alphabet_string(n, alphabet)
    if alphabet is not None:
        raise ValueError(&#34;Exactly one of &#39;encoding&#39; or &#39;alphabet&#39; must be specified.&#34;)
    if isinstance(encoding, SimpleBaseEncoding):
        return _rand_str_simple_enc(n, encoding)
    if isinstance(encoding, ZeropadBaseEncoding):
        return _rand_str_zeropad_enc(n, encoding)
    if isinstance(encoding, BlockBaseEncoding):
        return _rand_str_block_enc(n, encoding)
    if isinstance(encoding, FixcharBaseEncoding):
        return _rand_str_fixedchar_enc(n, encoding)
    raise ValueError(f&#34;Unsupported encoding type {type(encoding)}&#34;)</code></pre>
</details>
</dd>
<dt id="bases.random.reset_options"><code class="name flex">
<span>def <span class="ident">reset_options</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Resets random generation options to their default values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_options() -&gt; None:
    &#34;&#34;&#34;
        Resets random generation options to their default values.
    &#34;&#34;&#34;
    global _options
    global _rand
    _options = _default_options
    _rand = Random(0)</code></pre>
</details>
</dd>
<dt id="bases.random.set_options"><code class="name flex">
<span>def <span class="ident">set_options</span></span>(<span>*, seed: Optional[int] = None, min_bytes: Optional[int] = None, max_bytes: Optional[int] = None, min_chars: Optional[int] = None, max_chars: Optional[int] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Permanently sets random generation options:</p>
<pre><code class="language-python">    seed: int           # set new random number generator, with this seed
    min_bytes: int      # min length of `bytes` value
    max_bytes: int      # max length of `bytes` value
    min_chars: int      # min length of `str` value
    max_chars: int      # max length of `str` value
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_options(*,
                seed: Optional[int] = None,
                min_bytes: Optional[int] = None,
                max_bytes: Optional[int] = None,
                min_chars: Optional[int] = None,
                max_chars: Optional[int] = None,) -&gt; None:
    &#34;&#34;&#34;
        Permanently sets random generation options:

        ```python
            seed: int           # set new random number generator, with this seed
            min_bytes: int      # min length of `bytes` value
            max_bytes: int      # max length of `bytes` value
            min_chars: int      # min length of `str` value
            max_chars: int      # max length of `str` value
        ```

    &#34;&#34;&#34;
    # pylint: disable = too-many-branches, too-many-locals, too-many-statements
    for arg in (seed, min_bytes, max_bytes, min_chars, max_chars):
        validate(arg, Optional[int])
    global _options
    global _rand
    # set newly passed options
    _new_options: Dict[str, Any] = {}
    if seed is not None:
        _rand = Random(seed)
    if min_bytes is not None:
        if min_bytes &lt; 0:
            raise ValueError(&#34;Value for min_bytes is negative.&#34;)
        _new_options[&#34;min_bytes&#34;] = min_bytes
    if max_bytes is not None:
        if max_bytes &lt; 0:
            raise ValueError(&#34;Value for max_bytes is negative.&#34;)
        _new_options[&#34;max_bytes&#34;] = max_bytes
    if min_chars is not None:
        if min_chars &lt; 0:
            raise ValueError(&#34;Value for min_chars is negative.&#34;)
        _new_options[&#34;min_chars&#34;] = min_chars
    if max_chars is not None:
        if max_chars &lt; 0:
            raise ValueError(&#34;Value for max_chars is negative.&#34;)
        _new_options[&#34;max_chars&#34;] = max_chars
    # pass-through other options with former values
    for k, v in _options.items():
        if k not in _new_options:
            _new_options[k] = v
    # check compatibility conditions
    if _new_options[&#34;min_bytes&#34;] &gt; _new_options[&#34;max_bytes&#34;]:
        raise ValueError(&#34;Value for min_bytes is larger than value for max_bytes.&#34;)
    if _new_options[&#34;min_chars&#34;] &gt; _new_options[&#34;max_chars&#34;]:
        raise ValueError(&#34;Value for min_chars is larger than value for max_chars.&#34;)
    # update options
    _options = MappingProxyType(_new_options)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bases" href="index.html">bases</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="bases.random.default_options" href="#bases.random.default_options">default_options</a></code></li>
<li><code><a title="bases.random.get_options" href="#bases.random.get_options">get_options</a></code></li>
<li><code><a title="bases.random.options" href="#bases.random.options">options</a></code></li>
<li><code><a title="bases.random.rand_block_chars" href="#bases.random.rand_block_chars">rand_block_chars</a></code></li>
<li><code><a title="bases.random.rand_bytes" href="#bases.random.rand_bytes">rand_bytes</a></code></li>
<li><code><a title="bases.random.rand_char" href="#bases.random.rand_char">rand_char</a></code></li>
<li><code><a title="bases.random.rand_raw_bytes" href="#bases.random.rand_raw_bytes">rand_raw_bytes</a></code></li>
<li><code><a title="bases.random.rand_str" href="#bases.random.rand_str">rand_str</a></code></li>
<li><code><a title="bases.random.reset_options" href="#bases.random.reset_options">reset_options</a></code></li>
<li><code><a title="bases.random.set_options" href="#bases.random.set_options">set_options</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>